<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Print Job Simulator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the 3D container */
        #three-container {
            width: 100%;
            height: 100%;
            touch-action: none; /* Prevents unwanted scrolling on touch devices */
        }
        /* Ensure the body and html take full height */
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden; 
            font-family: 'Inter', sans-serif;
        }
        /* Custom scrollbar for control panel */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
        }
        /* Style for select dropdowns */
        select {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236b7280%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-13%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2013l128%20128c3.6%203.6%207.8%205.4%2013%205.4s9.4-1.8%2013-5.4l128-128c3.6-3.6%205.4-7.8%205.4-13%200-4.8-1.8-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.7rem center;
            background-size: 0.65em auto;
            padding-right: 2.5rem;
        }
    </style>
    <!-- Load Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body class="bg-gray-50 flex flex-col lg:flex-row h-full">

    <!-- Control Panel (Left/Top) -->
    <div class="lg:w-1/3 p-6 bg-white shadow-xl overflow-y-auto max-h-1/2 lg:max-h-full custom-scrollbar">
        <h1 class="text-3xl font-bold text-gray-800 mb-2">3D Print Job Simulator</h1>
        <p class="text-sm text-gray-600 mb-6">Select your print options to see a live 3D preview of the final printed sheets.</p>

        <!-- Printing Options -->
        <div class="mb-6 p-4 border border-indigo-200 rounded-xl bg-indigo-50">
            <h2 class="text-xl font-semibold text-indigo-800 mb-3">Print Settings</h2>
            
            <div class="grid grid-cols-2 gap-x-4 gap-y-4">
                <!-- Layout -->
                <div>
                    <label for="layout" class.="block text-sm font-medium text-gray-700">Layout</label>
                    <select id="layout" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:border-indigo-500 focus:ring-indigo-500">
                        <option value="portrait">Portrait</option>
                        <option value="landscape">Landscape</option>
                    </select>
                </div>

                <!-- Pages per Sheet -->
                <div>
                    <label for="pagesPerSheet" class="block text-sm font-medium text-gray-700">Pages per sheet</label>
                    <select id="pagesPerSheet" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:border-indigo-500 focus:ring-indigo-500">
                        <option value="1">1</option>
                        <option value="2">2</option>
                        <option value="4">4</option>
                        <option value="9">9</option>
                        <option value="16">16</option>
                    </select>
                </div>

                <!-- Margins -->
                <div>
                    <label for="margins" class="block text-sm font-medium text-gray-700">Margins</label>
                    <select id="margins" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 focus:border-indigo-500 focus:ring-indigo-500">
                        <option value="default">Default</option>
                        <option value="none">None</option>
                        <option value="minimum">Minimum</option>
                    </select>
                </div>

                <!-- Colour -->
                <div class="flex items-end pb-2">
                    <label class="flex items-center text-gray-700">
                        <input type="checkbox" id="grayscale" class="form-checkbox h-5 w-5 text-indigo-600 rounded">
                        <span class="ml-2 font-medium">Black and white</span>
                    </label>
                </div>
            </div>

            <hr class="my-4 border-t border-indigo-200">

            <!-- Duplex / Binding -->
            <fieldset class="mt-4 flex space-x-4 mb-2">
                <label class="flex items-center text-gray-700">
                    <input type="radio" id="simplex" name="printMode" value="simplex" class="form-radio h-4 w-4 text-indigo-600" checked>
                    <span class="ml-2 font-medium">Simplex (Single-Sided)</span>
                </label>
                <label class="flex items-center text-gray-700">
                    <input type="radio" id="duplex" name="printMode" value="duplex" class="form-radio h-4 w-4 text-indigo-600">
                    <span class="ml-2 font-medium">Duplex (Double-Sided)</span>
                </label>
            </fieldset>

            <fieldset class="flex space-x-6" id="binding-options">
                <label class="flex items-center text-gray-700">
                    <input type="radio" id="long-edge" name="bindingMode" value="long-edge" class="form-radio h-4 w-4 text-indigo-600" checked>
                    <span class="ml-2">Long-Edge (Book Flip)</span>
                </label>
                <label class="flex items-center text-gray-700">
                    <input type="radio" id="short-edge" name="bindingMode" value="short-edge" class="form-radio h-4 w-4 text-indigo-600">
                    <span class="ml-2">Short-Edge (Calendar Flip)</span>
                </label>
            </fieldset>
        </div>

        <!-- Page Input List -->
        <div class="mb-6 p-4 border border-gray-200 rounded-xl bg-white shadow-sm">
            <h2 class="text-xl font-semibold text-gray-800 mb-3">Page Content URLs (16 Pages Mock)</h2>
            <p class="text-xs text-gray-500 mb-3">Paste a direct image URL for each page. (Default placeholders used.)</p>
            <div id="page-inputs" class="space-y-3 max-h-64 overflow-y-auto custom-scrollbar pr-2">
                <!-- Page inputs will be injected here by JavaScript -->
            </div>
        </div>

        <!-- Page Navigation -->
        <div class="sticky bottom-0 bg-white pt-4 pb-2 border-t border-gray-200">
            <h2 id="page-status" class="text-center font-bold text-lg mb-4 text-gray-800">Sheet 1 (Page 1)</h2>
            <div class="flex justify-between items-center space-x-4">
                <button id="prev-btn" class="flex-1 py-3 px-4 bg-gray-200 text-gray-700 font-semibold rounded-xl shadow hover:bg-gray-300 transition duration-150 disabled:opacity-50" disabled>
                    <svg class="w-5 h-5 inline mr-1 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path></svg>
                    Previous
                </button>
                <button id="next-btn" class="flex-1 py-3 px-4 bg-indigo-600 text-white font-semibold rounded-xl shadow-lg hover:bg-indigo-700 transition duration-150 disabled:opacity-50">
                    Next
                    <svg class="w-5 h-5 inline ml-1 -mt-0.5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"></path></svg>
                </button>
            </div>
        </div>
    </div>

    <!-- 3D Viewer (Right/Bottom) -->
    <div id="three-container" class="lg:w-2/3 h-1/2 lg:h-full flex items-center justify-center bg-gray-900 shadow-inner relative">
        <!-- Three.js canvas will be injected here -->
        <!-- Two hidden 2D canvases for generating textures -->
        <canvas id="canvasFront" width="2048" height="2896" class="hidden"></canvas>
        <canvas id="canvasBack" width="2048" height="2896" class="hidden"></canvas>

        <div id="loading-overlay" class="absolute inset-0 bg-gray-900/80 flex flex-col items-center justify-center text-white z-10 hidden">
            <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-4 text-sm">Loading Page Textures...</p>
        </div>
        <div class="absolute top-4 right-4 text-white text-md p-2 bg-black/50 rounded-lg">
            Drag to rotate paper.
        </div>
    </div>

    <script>
        // --- Three.js Globals ---
        let scene, camera, renderer, paperMesh, textureFront, textureBack, meshFront, meshBack;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        const dragFactor = 0.01;
        // Base dimensions (A4-like ratio)
        const A4_WIDTH = 10;
        const A4_HEIGHT = 14.14; 
        
        // --- App State ---
        const totalPages = 16;
        let currentPageIndex = 0; // The index of the *first* page on the current sheet
        let state = {
            isDuplex: false,
            bindingMode: 'long-edge',
            layout: 'portrait',
            pagesPerSheet: 1,
            margins: 'default',
            isGrayscale: false
        };
        
        const pageData = []; 
        const placeholderBase = "https://placehold.co/800x1131/ffffff/000000?text=";
        
        // Canvas elements for textures
        let canvasFront, canvasBack;

        // --- Setup Functions ---

        /**
         * Initializes the page content data structure and HTML inputs.
         */
        function initializePageData() {
            const pageInputContainer = document.getElementById('page-inputs');
            
            for (let i = 0; i < totalPages; i++) {
                const pageNumber = i + 1;
                pageData.push({
                    url: `${placeholderBase}Page%20${pageNumber}`
                });
                
                const div = document.createElement('div');
                div.innerHTML = `
                    <label for="page-url-${i}" class="block text-sm font-medium text-gray-700">Page ${pageNumber} URL</label>
                    <input type="text" id="page-url-${i}" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm p-2 text-sm" value="${pageData[i].url}">
                `;
                div.querySelector('input').addEventListener('input', (e) => {
                    pageData[i].url = e.target.value;
                    renderCurrentPages();
                });
                pageInputContainer.appendChild(div);
            }
        }

        /**
         * Helper to load an image from a URL. Uses crossOrigin for canvas compatibility.
         * @param {string} url - The image URL.
         * @returns {Promise<Image>}
         */
        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'Anonymous'; // Essential for drawing cross-domain images to canvas
                img.onload = () => resolve(img);
                img.onerror = () => {
                    console.error(`Failed to load image: ${url}`);
                    // Create a fallback error image
                    const errorCanvas = document.createElement('canvas');
                    errorCanvas.width = 800; errorCanvas.height = 1131;
                    const ctx = errorCanvas.getContext('2d');
                    ctx.fillStyle = '#FFDDDD';
                    ctx.fillRect(0, 0, 800, 1131);
                    ctx.font = 'bold 60px Inter';
                    ctx.fillStyle = 'red';
                    ctx.textAlign = 'center';
                    ctx.fillText('Load Error', 400, 565);
                    // Create an Image from the error canvas
                    const errorImg = new Image();
                    errorImg.src = errorCanvas.toDataURL();
                    errorImg.onload = () => resolve(errorImg); // Resolve with the error image
                };
                img.src = url;
            });
        }
        
        /**
         * Draws the complete sheet (with multiple pages) onto a canvas.
         * @param {HTMLCanvasElement} canvas - The target canvas (front or back).
         * @param {number[]} pageIndices - Array of page indices to draw.
         */
        async function drawSheet(canvas, pageIndices) {
            const { layout, pagesPerSheet, margins, isGrayscale } = state;
            const ctx = canvas.getContext('2d');

            // 1. Set Canvas Dimensions based on Layout
            const canvasWidth = (layout === 'portrait') ? 2048 : 2896;
            const canvasHeight = (layout === 'portrait') ? 2896 : 2048;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // 2. Clear canvas
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // 3. Determine Grid
            let cols = 1, rows = 1;
            if (pagesPerSheet == 2) { (layout === 'portrait') ? rows = 2 : cols = 2; }
            else if (pagesPerSheet == 4) { cols = 2; rows = 2; }
            else if (pagesPerSheet == 9) { cols = 3; rows = 3; }
            else if (pagesPerSheet == 16) { cols = 4; rows = 4; }

            // 4. Determine Margins
            let marginPx = 0;
            if (margins === 'default') marginPx = Math.min(canvasWidth, canvasHeight) * 0.05;
            if (margins === 'minimum') marginPx = Math.min(canvasWidth, canvasHeight) * 0.02;

            const cellWidth = (canvasWidth - 2 * marginPx) / cols;
            const cellHeight = (canvasHeight - 2 * marginPx) / rows;
            const gap = Math.min(cellWidth, cellHeight) * 0.04; // Small gap between pages

            const pageW = cellWidth - gap;
            const pageH = cellHeight - gap;

            // 5. Load all images for this sheet concurrently
            const imagePromises = pageIndices.map(index => {
                const page = pageData[index];
                return page ? loadImage(page.url) : Promise.resolve(null);
            });
            const images = await Promise.all(imagePromises);

            // 6. Draw pages onto canvas
            for (let i = 0; i < images.length; i++) {
                const img = images[i];
                if (!img) continue; // Skip if page doesn't exist

                const r = Math.floor(i / cols);
                const c = i % cols;

                const x = marginPx + c * cellWidth + gap / 2;
                const y = marginPx + r * cellHeight + gap / 2;

                // Fit image into (pageW, pageH) maintaining aspect ratio
                const hRatio = pageW / img.width;
                const vRatio = pageH / img.height;
                const ratio = Math.min(hRatio, vRatio);
                
                const drawW = img.width * ratio;
                const drawH = img.height * ratio;
                
                // Center image in its cell
                const drawX = x + (pageW - drawW) / 2;
                const drawY = y + (pageH - drawH) / 2;

                ctx.drawImage(img, drawX, drawY, drawW, drawH);
            }

            // 7. Apply Grayscale Filter (if needed)
            if (isGrayscale) {
                const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const avg = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    data[i] = avg;     // red
                    data[i + 1] = avg; // green
                    data[i + 2] = avg; // blue
                }
                ctx.putImageData(imageData, 0, 0);
            }
        }
        
        /**
         * Updates the 3D model textures based on current state.
         */
        async function renderCurrentPages() {
            document.getElementById('loading-overlay').classList.remove('hidden');
            
            const { isDuplex, pagesPerSheet, bindingMode, layout } = state;
            
            // --- Determine Page Indices ---
            const step = isDuplex ? pagesPerSheet * 2 : pagesPerSheet;
            
            const frontPageIndices = [];
            for (let i = 0; i < pagesPerSheet; i++) {
                frontPageIndices.push(currentPageIndex + i);
            }
            
            const backPageIndices = [];
            if (isDuplex) {
                for (let i = 0; i < pagesPerSheet; i++) {
                    backPageIndices.push(currentPageIndex + pagesPerSheet + i);
                }
            }
            
            // --- Draw Textures Concurrently ---
            await Promise.all([
                drawSheet(canvasFront, frontPageIndices),
                drawSheet(canvasBack, isDuplex ? backPageIndices : []) // Draw blank if simplex
            ]);

            // --- Apply Binding Mode Rotation ---
            if (meshBack) {
                let rotateZ = false;
                
                // Portrait Layout (w < h)
                if (layout === 'portrait') {
                    if (bindingMode === 'short-edge') rotateZ = true;
                }
                // Landscape Layout (w > h)
                else {
                    if (bindingMode === 'long-edge') rotateZ = true;
                }
                
                meshBack.rotation.z = (isDuplex && rotateZ) ? Math.PI : 0;
            }
            
            // --- Notify Three.js to update textures ---
            textureFront.needsUpdate = true;
            textureBack.needsUpdate = true;
            
            document.getElementById('loading-overlay').classList.add('hidden');
            updateNavigationStatus();
        }

        /**
         * Updates navigation buttons (disabled status) and page status text.
         */
        function updateNavigationStatus() {
            const { isDuplex, pagesPerSheet } = state;
            const step = isDuplex ? pagesPerSheet * 2 : pagesPerSheet;
            
            const maxIndex = totalPages - (totalPages % step || step);
            const sheetNumber = Math.floor(currentPageIndex / step) + 1;
            const totalSheets = Math.ceil(totalPages / step);
            
            // Button States
            document.getElementById('prev-btn').disabled = currentPageIndex === 0;
            document.getElementById('next-btn').disabled = currentPageIndex >= maxIndex || (currentPageIndex + step) >= totalPages;
            
            // Status Text
            let pageRange = "";
            if (pagesPerSheet === 1) {
                pageRange = `Page ${currentPageIndex + 1}`;
                if (isDuplex && (currentPageIndex + 1) < totalPages) pageRange += ` & ${currentPageIndex + 2}`;
            } else {
                const endPage = Math.min(currentPageIndex + step - 1, totalPages - 1);
                pageRange = `Pages ${currentPageIndex + 1}-${endPage + 1}`;
            }
            
            document.getElementById('page-status').textContent = `Sheet ${sheetNumber} of ${totalSheets} (${pageRange})`;
            
            // Highlight active page inputs
            document.querySelectorAll('#page-inputs input').forEach((input, index) => {
                input.classList.remove('border-indigo-500', 'ring-2', 'ring-indigo-200', 'bg-indigo-50');
                if (index >= currentPageIndex && index < (currentPageIndex + step)) {
                    input.classList.add('border-indigo-500', 'ring-2', 'ring-indigo-200', 'bg-indigo-50');
                }
            });

            // Toggle binding options
            const bindingFieldset = document.getElementById('binding-options');
            if (isDuplex) {
                bindingFieldset.classList.remove('opacity-50', 'pointer-events-none');
            } else {
                bindingFieldset.classList.add('opacity-50', 'pointer-events-none');
            }
        }

        /**
         * Recreates the paper geometry when layout changes.
         */
        function updatePaperGeometry() {
            const { layout } = state;

            // Determine dimensions
            const w = (layout === 'portrait') ? A4_WIDTH : A4_HEIGHT;
            const h = (layout === 'portrait') ? A4_HEIGHT : A4_WIDTH;

            // Clear old geometry if it exists
            if (meshFront) paperMesh.remove(meshFront);
            if (meshBack) paperMesh.remove(meshBack);

            // 1. Create new Geometry
            const geometry = new THREE.PlaneGeometry(w, h, 1, 1);
            
            // 2. Create new Materials (pointing to existing textures)
            const materialFront = new THREE.MeshPhongMaterial({
                map: textureFront, side: THREE.FrontSide, shininess: 50
            });
            const materialBack = new THREE.MeshPhongMaterial({
                map: textureBack, side: THREE.FrontSide, shininess: 50
            });
            
            // 3. Create new Meshes
            meshFront = new THREE.Mesh(geometry, materialFront);
            meshFront.position.z = 0.001; 
            
            meshBack = new THREE.Mesh(geometry, materialBack);
            meshBack.rotation.y = Math.PI; // Basic 180 flip
            meshBack.position.z = -0.001; 
            
            // 4. Add to group
            paperMesh.add(meshFront);
            paperMesh.add(meshBack);

            // Re-apply current rotation/binding
            renderCurrentPages();
        }

        /**
         * Initializes the Three.js scene, camera, and paper model.
         */
        function initThreeJS() {
            const container = document.getElementById('three-container');
            canvasFront = document.getElementById('canvasFront');
            canvasBack = document.getElementById('canvasBack');

            // 1. Scene & Camera
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c);
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 25;

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            // 3. Lighting
            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const dirLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight1.position.set(5, 5, 5);
            scene.add(dirLight1);
            const dirLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight2.position.set(-5, -5, -5);
            scene.add(dirLight2);
            
            // 4. Textures (from hidden canvases)
            textureFront = new THREE.CanvasTexture(canvasFront);
            textureBack = new THREE.CanvasTexture(canvasBack);
            
            // 5. Paper Mesh (Group)
            paperMesh = new THREE.Group();
            paperMesh.rotation.x = Math.PI * -0.15;
            paperMesh.rotation.y = Math.PI * -0.25;
            scene.add(paperMesh);
            
            // 6. Initial Geometry & Render
            updatePaperGeometry(); 
            
            // --- Interaction Setup ---
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('touchstart', onTouchStart, false);
            renderer.domElement.addEventListener('touchmove', onTouchMove, false);
            renderer.domElement.addEventListener('touchend', onMouseUp, false); 
            window.addEventListener('resize', onWindowResize);
            
            animate();
        }

        // --- Event Handlers ---
        
        function onWindowResize() {
            const container = document.getElementById('three-container');
            if (container) {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function navigate(direction) {
            const { isDuplex, pagesPerSheet } = state;
            const step = isDuplex ? pagesPerSheet * 2 : pagesPerSheet;
            const newIndex = currentPageIndex + (direction * step);
            
            if (newIndex >= 0 && newIndex < totalPages) {
                currentPageIndex = newIndex;
                renderCurrentPages();
            }
        }
        
        // Dragging logic
        function getClientX(e) { return e.clientX || e.touches[0].clientX; }
        function getClientY(e) { return e.clientY || e.touches[0].clientY; }
        function onMouseDown(e) { e.preventDefault(); isDragging = true; previousMousePosition.x = getClientX(e); previousMousePosition.y = getClientY(e); }
        function onTouchStart(e) { e.preventDefault(); isDragging = true; previousMousePosition.x = getClientX(e); previousMousePosition.y = getClientY(e); }
        function onMouseMove(e) {
            if (!isDragging) return;
            paperMesh.rotation.y += (getClientX(e) - previousMousePosition.x) * dragFactor;
            paperMesh.rotation.x += (getClientY(e) - previousMousePosition.y) * dragFactor;
            previousMousePosition.x = getClientX(e);
            previousMousePosition.y = getClientY(e);
        }
        function onTouchMove(e) { onMouseMove(e); }
        function onMouseUp(e) { isDragging = false; }

        /**
         * Collects all form inputs into the state object and triggers a re-render.
         */
        function updateStateAndRender() {
            state.isDuplex = document.getElementById('duplex').checked;
            state.bindingMode = document.querySelector('input[name="bindingMode"]:checked').value;
            state.layout = document.getElementById('layout').value;
            state.pagesPerSheet = parseInt(document.getElementById('pagesPerSheet').value, 10);
            state.margins = document.getElementById('margins').value;
            state.isGrayscale = document.getElementById('grayscale').checked;

            // When layout changes, we must rebuild the 3D geometry
            const currentWidth = (paperMesh.children[0]?.geometry.parameters.width || 0);
            const newWidth = (state.layout === 'portrait') ? A4_WIDTH : A4_HEIGHT;
            
            if (currentWidth !== newWidth) {
                // updatePaperGeometry will call renderCurrentPages
                updatePaperGeometry();
            } else {
                // Otherwise, just re-draw textures
                renderCurrentPages();
            }
        }

        // --- Initialization on Load ---
        window.onload = function() {
            initializePageData();
            initThreeJS();
            
            // Attach listeners to all controls
            document.querySelectorAll('input[name="printMode"]').forEach(radio => radio.addEventListener('change', () => {
                currentPageIndex = 0; // Reset page on mode change
                updateStateAndRender();
            }));
            document.querySelectorAll('input[name="bindingMode"]').forEach(radio => radio.addEventListener('change', updateStateAndRender));
            document.getElementById('layout').addEventListener('change', () => {
                currentPageIndex = 0; // Reset page on layout change
                updateStateAndRender();
            });
            document.getElementById('pagesPerSheet').addEventListener('change', () => {
                currentPageIndex = 0; // Reset page on pagesPerSheet change
                updateStateAndRender();
            });
            document.getElementById('margins').addEventListener('change', updateStateAndRender);
            document.getElementById('grayscale').addEventListener('change', updateStateAndRender);

            // Attach navigation listeners
            document.getElementById('prev-btn').addEventListener('click', () => navigate(-1));
            document.getElementById('next-btn').addEventListener('click', () => navigate(1));
        }
    </script>
</body>
</html>

