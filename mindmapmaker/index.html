<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Creator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Use Inter font -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    
    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevents pull-to-refresh */
        }
        
        /* The main canvas area */
        #canvas {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden; /* We'll manage our own overflow */
            background-color: #f3f4f6; /* bg-gray-100 */
            /* A subtle grid background */
            background-image:
                linear-gradient(to right, #e5e7eb 1px, transparent 1px),
                linear-gradient(to bottom, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        /* SVG container for lines */
        #line-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            pointer-events: none; /* Allows clicking through to the canvas */
        }

        /* Connecting lines */
        .line {
            stroke: #6b7280; /* gray-500 */
            stroke-width: 3;
            transition: all 0.1s ease-in-out;
        }

        /* Mind map nodes */
        .node {
            position: absolute;
            z-index: 10;
            min-width: 150px;
            background-color: white;
            border-radius: 0.5rem; /* rounded-lg */
            padding: 0.75rem 1rem; /* p-3 p-4 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            border: 2px solid transparent;
            cursor: move;
            transition: all 0.1s ease-in-out;
            user-select: none; /* Don't select text when dragging */
        }
        
        .node:hover {
             box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
        }

        /* Selected node style */
        .node.selected {
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.3), 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        /* Make the text editable */
        .node-text {
            outline: none;
            user-select: text; /* Allow selecting text for editing */
            cursor: text;
            min-height: 1.5rem; /* Ensure it's clickable */
        }
        
        /* Simple modal for instructions */
        #instructions {
            transition: opacity 0.3s ease-in-out;
        }

        /* Hide the default file input */
        #import-input {
            display: none;
        }
    </style>
</head>
<body class="flex flex-col h-screen overflow-hidden">

    <!-- Toolbar -->
    <header class="bg-white shadow-md z-30 p-2 flex items-center space-x-2">
        <h1 class="text-xl font-bold text-gray-800 px-2 hidden sm:block">Mind Map</h1>
        
        <!-- Action Buttons -->
        <button id="add-node-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150">
            Add Node
        </button>
        <button id="delete-node-btn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150" disabled>
            Delete Node
        </button>
        
        <div class="flex-grow"></div> <!-- Spacer -->
        
        <!-- Import/Export Buttons -->
        <button id="export-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150">
            Export
        </button>
        <button id="import-btn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150">
            Import
        </button>
        <input type="file" id="import-input" accept=".json">

        <!-- Help Button -->
        <button id="help-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold p-2 rounded-full w-10 h-10 shadow transition duration-150">
            ?
        </button>
    </header>

    <!-- Main Canvas Area -->
    <main id="canvas" class="flex-grow">
        <!-- SVG layer for drawing lines -->
        <svg id="line-svg"></svg>
        
        <!-- Nodes will be added here dynamically by JS -->
    </main>

    <!-- Instructions Modal -->
    <div id="instructions" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 transition-opacity opacity-0 pointer-events-none">
        <div class="bg-white p-6 rounded-lg shadow-2xl max-w-md w-full m-4">
            <h2 class="text-2xl font-bold mb-4">How to Use</h2>
            <ul class="list-disc list-inside space-y-2 text-gray-700">
                <li><strong class="font-semibold">Add Node:</strong> Click 'Add Node'. If a node is selected, it branches off.</li>
                <li><strong class="font-semibold">Edit Text:</strong> Click the text inside a node.</li>
                <li><strong class="font-semibold">Move Node:</strong> Click and drag a node.</li>
                <li><strong class="font-semibold">Select Node:</strong> Click a node (not on its text).</li>
                <li><strong class="font-semibold">Delete Node:</strong> Select a node and press 'Delete' or click 'Delete Node'.</li>
                <li><strong class="font-semibold">Deselect:</strong> Click on the blank canvas.</li>
            </ul>
            <button id="close-help-btn" class="mt-6 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150">
                Got it!
            </button>
        </div>
    </div>
    
    <!-- JavaScript Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('canvas');
            const svg = document.getElementById('line-svg');
            
            // Buttons
            const addNodeBtn = document.getElementById('add-node-btn');
            const deleteNodeBtn = document.getElementById('delete-node-btn');
            const exportBtn = document.getElementById('export-btn');
            const importBtn = document.getElementById('import-btn');
            const importInput = document.getElementById('import-input');
            const helpBtn = document.getElementById('help-btn');
            const closeHelpBtn = document.getElementById('close-help-btn');
            const instructionsModal = document.getElementById('instructions');

            // State
            let nodes = [];
            let links = [];
            let selectedNodeId = null;
            let draggingNode = null;
            let dragOffset = { x: 0, y: 0 };
            
            /**
             * Renders all connecting lines based on the current state.
             */
            function renderLinks() {
                // Clear existing lines
                svg.innerHTML = '';
                
                links.forEach(link => {
                    const fromNode = nodes.find(n => n.id === link.from);
                    const toNode = nodes.find(n => n.id === link.to);
                    
                    if (!fromNode || !toNode || !fromNode.element || !toNode.element) return;
                    
                    // Calculate center points
                    const x1 = fromNode.x + fromNode.element.offsetWidth / 2;
                    const y1 = fromNode.y + fromNode.element.offsetHeight / 2;
                    const x2 = toNode.x + toNode.element.offsetWidth / 2;
                    const y2 = toNode.y + toNode.element.offsetHeight / 2;
                    
                    // Create SVG line
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x1);
                    line.setAttribute('y1', y1);
                    line.setAttribute('x2', x2);
                    line.setAttribute('y2', y2);
                    line.setAttribute('class', 'line');
                    svg.appendChild(line);
                });
            }

            /**
             * Selects a node.
             */
            function selectNode(id) {
                // Deselect previous
                if (selectedNodeId) {
                    const oldNode = nodes.find(n => n.id === selectedNodeId);
                    if (oldNode) {
                        oldNode.element.classList.remove('selected');
                    }
                }
                
                // Select new
                selectedNodeId = id;
                if (selectedNodeId) {
                    const newNode = nodes.find(n => n.id === selectedNodeId);
                    if (newNode) {
                        newNode.element.classList.add('selected');
                        deleteNodeBtn.disabled = false;
                    }
                } else {
                    deleteNodeBtn.disabled = true;
                }
            }

            /**
             * Creates a new node element and adds it to the state.
             */
            function createNode(text, x, y, id = null) {
                const nodeId = id || `node_${new Date().getTime()}_${Math.random()}`;
                
                const nodeDiv = document.createElement('div');
                nodeDiv.id = nodeId;
                nodeDiv.className = 'node';
                nodeDiv.style.left = `${x}px`;
                nodeDiv.style.top = `${y}px`;
                
                const textEl = document.createElement('div');
                textEl.className = 'node-text';
                textEl.innerText = text;
                textEl.contentEditable = true;
                
                nodeDiv.appendChild(textEl);
                canvas.appendChild(nodeDiv);
                
                const node = {
                    id: nodeId,
                    text: text,
                    x: x,
                    y: y,
                    element: nodeDiv
                };
                
                // --- Event Listeners for the Node ---

                // 1. Click to Select
                nodeDiv.addEventListener('click', (e) => {
                    // Don't select if clicking on the editable text area
                    if (e.target !== textEl) {
                        e.stopPropagation();
                        selectNode(node.id);
                    }
                });

                // 2. Mousedown to start dragging
                nodeDiv.addEventListener('mousedown', (e) => {
                    // Don't drag if clicking on the editable text area
                    if (e.target === textEl) return;
                    
                    e.stopPropagation();
                    draggingNode = node;
                    dragOffset.x = e.clientX - node.x;
                    dragOffset.y = e.clientY - node.y;
                    
                    // Add global listeners to handle dragging outside the node
                    document.addEventListener('mousemove', onDrag);
                    document.addEventListener('mouseup', stopDrag);
                });

                // 3. Update text in state
                textEl.addEventListener('input', (e) => {
                    node.text = e.target.innerText;
                });

                nodes.push(node);
                return node;
            }

            // --- Global Drag Handlers ---
            
            function onDrag(e) {
                if (!draggingNode) return;
                
                e.preventDefault(); // Prevent text selection
                
                let newX = e.clientX - dragOffset.x;
                let newY = e.clientY - dragOffset.y;
                
                // Snap to grid (optional, but nice)
                // newX = Math.round(newX / 20) * 20;
                // newY = Math.round(newY / 20) * 20;

                // Constrain to canvas boundaries
                const canvasRect = canvas.getBoundingClientRect();
                newX = Math.max(0, Math.min(newX, canvasRect.width - draggingNode.element.offsetWidth));
                newY = Math.max(0, Math.min(newY, canvasRect.height - draggingNode.element.offsetHeight));

                draggingNode.x = newX;
                draggingNode.y = newY;
                draggingNode.element.style.left = `${newX}px`;
                draggingNode.element.style.top = `${newY}px`;
                
                // Update lines in real-time
                renderLinks();
            }

            function stopDrag() {
                draggingNode = null;
                document.removeEventListener('mousemove', onDrag);
                document.removeEventListener('mouseup', stopDrag);
            }

            // --- Button Actions ---

            function handleAddNode() {
                let x, y;
                const parentNode = nodes.find(n => n.id === selectedNodeId);
                
                if (parentNode) {
                    // Offset from parent
                    x = parentNode.x + parentNode.element.offsetWidth + 50;
                    y = parentNode.y;
                } else {
                    // Place in center of canvas
                    const canvasRect = canvas.getBoundingClientRect();
                    x = (canvasRect.width / 2) - 75; // 75 = half node width
                    y = (canvasRect.height / 2) - 30;
                }
                
                const newNode = createNode('New Idea', x, y);
                
                if (parentNode) {
                    links.push({ from: parentNode.id, to: newNode.id });
                }
                
                selectNode(newNode.id);
                renderLinks();
                
                // Focus the new node's text
                const textEl = newNode.element.querySelector('.node-text');
                textEl.focus();
                document.execCommand('selectAll', false, null);
            }

            function handleDeleteNode() {
                if (!selectedNodeId) return;
                
                // Remove node from state
                const nodeIndex = nodes.findIndex(n => n.id === selectedNodeId);
                if (nodeIndex > -1) {
                    nodes[nodeIndex].element.remove(); // Remove from DOM
                    nodes.splice(nodeIndex, 1); // Remove from array
                }
                
                // Remove associated links
                links = links.filter(link => link.from !== selectedNodeId && link.to !== selectedNodeId);
                
                selectedNodeId = null;
                deleteNodeBtn.disabled = true;
                renderLinks();
            }

            function handleExport() {
                // Save a clean version without DOM elements
                const cleanNodes = nodes.map(n => ({
                    id: n.id,
                    text: n.text,
                    x: n.x,
                    y: n.y
                }));
                
                const data = {
                    nodes: cleanNodes,
                    links: links
                };
                
                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
                const downloadAnchor = document.createElement('a');
                downloadAnchor.setAttribute("href", dataStr);
                downloadAnchor.setAttribute("download", "mindmap.json");
                document.body.appendChild(downloadAnchor);
                downloadAnchor.click();
                downloadAnchor.remove();
            }

            function handleImport() {
                importInput.click(); // Trigger hidden file input
            }
            
            importInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data && data.nodes && data.links) {
                            // Clear existing map
                            nodes.forEach(n => n.element.remove());
                            nodes = [];
                            links = [];
                            svg.innerHTML = '';
                            
                            // Recreate map
                            data.nodes.forEach(nodeData => {
                                createNode(nodeData.text, nodeData.x, nodeData.y, nodeData.id);
                            });
                            links = data.links;
                            renderLinks();
                        }
                    } catch (err) {
                        console.error("Error parsing JSON file:", err);
                        // In a real app, show a user-friendly error
                    }
                };
                reader.readAsText(file);
                
                // Reset input value to allow importing the same file again
                event.target.value = null;
            });

            // --- Global Listeners ---

            // Click on canvas to deselect
            canvas.addEventListener('click', () => {
                selectNode(null);
            });

            // Keyboard listener for Delete key
            window.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodeId) {
                    // Don't delete if user is editing text
                    if (document.activeElement.classList.contains('node-text')) {
                        return;
                    }
                    e.preventDefault();
                    handleDeleteNode();
                }
            });
            
            // Re-render links on window resize (as node offsets might change)
            window.addEventListener('resize', renderLinks);

            // --- Help Modal Logic ---
            helpBtn.addEventListener('click', () => {
                instructionsModal.classList.remove('opacity-0', 'pointer-events-none');
            });
            closeHelpBtn.addEventListener('click', () => {
                instructionsModal.classList.add('opacity-0', 'pointer-events-none');
            });

            // --- Initialization ---
            function init() {
                // Create a root node to start
                const canvasRect = canvas.getBoundingClientRect();
                const startX = (canvasRect.width / 2) - 75;
                const startY = (canvasRect.height / 3) - 30;
                const rootNode = createNode('Main Idea', startX, startY);
                selectNode(rootNode.id);
                
                // Show help on first load
                instructionsModal.classList.remove('opacity-0', 'pointer-events-none');
            }

            // --- Button Event Listeners ---
            addNodeBtn.addEventListener('click', handleAddNode);
            deleteNodeBtn.addEventListener('click', handleDeleteNode);
            exportBtn.addEventListener('click', handleExport);
            importBtn.addEventListener('click', handleImport);

            // Start the application
            init();
        });
    </script>

</body>
</html>
