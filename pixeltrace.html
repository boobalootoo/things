<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'primary': '#4f46e5',
                        'primary-dark': '#4338ca',
                        'secondary': '#facc15',
                        'danger': '#e11d48',
                        'danger-dark': '#be123c',
                        'background': '#fefefe',
                        'panel': '#ffffff',
                    }
                }
            }
        }
    </script>
    <style>
        /* Main container for all stacked layers */
        .layer-container {
            position: relative;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
            background-color: #f3f4f6; /* Fallback background */
            /* Aspect ratio will be set by JS */
        }

        /* Common style for all layers */
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Pass clicks through by default */
        }

        /* The drawing canvas is the only one that accepts clicks */
        #drawingCanvas {
            pointer-events: auto;
            cursor: crosshair;
        }

        /* The grid pattern layer */
        #gridPattern {
            background-image: linear-gradient(to right, #888 1px, transparent 1px),
                              linear-gradient(to bottom, #888 1px, transparent 1px);
            /* Background-size will be set by JS */
        }

        /* Style for custom file input appearance */
        .file-upload-label {
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .file-upload-label:hover {
            background-color: #f3f4f6;
        }

        /* Re-usable button for movement */
        .control-button {
            @apply p-2 bg-primary text-white rounded-lg hover:bg-primary-dark transition shadow-md;
        }
        
        /* Custom appearance for range sliders */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 16px; height: 16px;
            background: #4f46e5; /* primary color */
            cursor: pointer; border-radius: 50%;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        input[type=range]::-moz-range-thumb {
            width: 16px; height: 16px;
            background: #4f46e5;
            cursor: pointer; border-radius: 50%;
            box-shadow: 0 0 2px rgba(0,0,0,0.3);
            border: none;
        }
        input[type=range]:disabled::-webkit-slider-thumb {
            background: #9ca3af; /* gray-400 */
        }
        input[type=range]:disabled::-moz-range-thumb {
            background: #9ca3af; /* gray-400 */
        }
        
        /* Toggle switch for eraser */
        .toggle-bg:after {
            content: '';
            @apply absolute top-0.5 left-0.5 bg-white border border-gray-300 rounded-full h-5 w-5 transition-all shadow;
        }
        input:checked + .toggle-bg:after {
            @apply transform translate-x-full border-white;
        }
        input:checked + .toggle-bg {
            @apply bg-primary;
        }

        /* Styles for the tool buttons */
        .toolbar-btn {
            @apply p-2 rounded-lg border border-gray-300 bg-white hover:bg-gray-100 transition-colors duration-150;
        }
        .toolbar-btn.active {
            @apply bg-primary text-white border-primary-dark shadow-inner;
        }
        .toolbar-btn svg {
            @apply w-5 h-5;
            color: #374151; /* Default icon color (text-gray-700) */
        }
        .toolbar-btn.active svg {
            color: #ffffff; /* Active icon color (text-white) */
        }

        /* NEW: Modal Styles */
        .modal-overlay {
            @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 transition-opacity duration-300;
        }
        .modal-content {
            @apply bg-white p-6 rounded-lg shadow-xl w-full max-w-sm transform transition-all scale-95 duration-300;
        }
        .modal-visible .modal-overlay {
            @apply opacity-100;
        }
        .modal-visible .modal-content {
            @apply scale-100;
        }
        .modal-hidden .modal-overlay {
            @apply opacity-0 pointer-events-none;
        }
        .modal-hidden .modal-content {
            @apply scale-95 pointer-events-none;
        }
        .modal-btn {
            @apply px-4 py-2 rounded-lg font-medium transition-colors;
        }
        .modal-btn-primary {
            @apply bg-primary text-white hover:bg-primary-dark;
        }
        .modal-btn-danger {
            @apply bg-danger text-white hover:bg-danger-dark;
        }
        .modal-btn-secondary {
            @apply bg-gray-200 text-gray-800 hover:bg-gray-300;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans min-h-screen flex flex-col items-center p-4 sm:p-8">

    <!-- Main Application Content -->
    <div id="appContainer" class="w-full max-w-7xl">
        <h1 class="text-4xl font-extrabold text-gray-800 mb-6 text-center">Pixel Art Studio</h1>
        
        <div class="flex flex-col lg:flex-row gap-8">
            
            <!-- Control Panel (Left) -->
            <div class="lg:w-1/3 bg-panel p-6 rounded-xl shadow-lg border border-gray-200 h-fit">
                <h2 class="text-xl font-semibold text-gray-800 mb-4 border-b pb-2">Setup</h2>
                
                <!-- Image Upload -->
                <div class="mb-6">
                    <label class="file-upload-label block w-full text-center p-3 border-2 border-dashed border-gray-300 rounded-lg bg-white hover:bg-gray-50 transition duration-150">
                        <input type="file" id="imageUpload" accept="image/*" class="hidden" onchange="handleImageUpload(event)">
                        <span class="text-primary font-medium">Upload Reference Image</span>
                        <p id="fileName" class="text-xs text-gray-500 mt-1 truncate">No file selected</p>
                    </label>
                </div>

                <!-- NEW: Start with Blank Canvas -->
                <div class="mb-6 text-center">
                    <button onclick="startWithBlankCanvas()" class="w-full p-3 bg-gray-600 text-white font-medium rounded-lg hover:bg-gray-700 transition shadow">
                        Start with Blank Canvas
                    </button>
                </div>
                
                <!-- This section is disabled until an image is uploaded or blank canvas is created -->
                <div id="controlsWrapper" class="opacity-40 pointer-events-none">
                
                    <!-- Pixelation -->
                    <div class="mb-4">
                        <label for="pixelationSlider" class="block text-sm font-medium text-gray-700 mb-2">
                            Pixelation: <span id="pixelationValue" class="font-bold">1</span>x
                        </label>
                        <input type="range" id="pixelationSlider" min="1" max="32" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" oninput="updatePixelation(this.value)">
                        <p class="text-xs text-gray-500 mt-1">Grid: <span id="gridSizeLabel">N/A</span></p>
                    </div>

                    <!-- Bit Depth -->
                    <div class="mb-4">
                        <label for="bitDepthSlider" class="block text-sm font-medium text-gray-700 mb-2">
                            Color Bit Depth: <span id="bitDepthValue" class="font-bold">8</span> bits/channel
                        </label>
                        <input type="range" id="bitDepthSlider" min="1" max="8" value="8" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" oninput="document.getElementById('bitDepthValue').textContent = this.value">
                    </div>
                    
                    <!-- Generation Button -->
                    <div class="text-center mt-6 mb-6" id="generatePixelBtnWrapper">
                        <button onclick="generatePixelArt()" id="generatePixelBtn" class="w-full p-3 bg-secondary text-gray-900 font-semibold rounded-lg hover:bg-yellow-500 transition shadow-lg">
                            Generate Pixel Art
                        </button>
                    </div>

                    <!-- Layer Controls -->
                    <h2 class="text-xl font-semibold text-gray-800 mb-4 border-t pt-4">Layers & Tools</h2>
                    
                    <!-- Brush Size -->
                    <div class="mb-4">
                        <label for="brushSizeSlider" class="block text-sm font-medium text-gray-700 mb-2">
                            Brush Size: <span id="brushSizeValue" class="font-bold">1x1</span>
                        </label>
                        <input type="range" id="brushSizeSlider" min="1" max="5" value="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" oninput="updateBrushSize(this.value)">
                    </div>

                    <!-- NEW: Clear Drawing -->
                    <div class="mb-4">
                        <button onclick="confirmClearDrawing()" class="w-full p-2 bg-danger text-white text-sm font-medium rounded-lg hover:bg-danger-dark transition shadow-sm">
                            Clear Drawing Layer
                        </button>
                    </div>

                    <!-- Layer Stack -->
                    <div class="space-y-3">
                        <!-- Layer: Drawing -->
                        <div class="p-3 border rounded-lg">
                            <div class="flex justify-between items-center mb-2">
                                <label for="toggleDrawing" class="font-medium text-gray-700">Drawing Layer</label>
                                <input type="checkbox" id="toggleDrawing" checked onchange="toggleLayer('drawingCanvas', this.checked)">
                            </div>
                            <input type="range" min="0" max="100" value="100" class="w-full" oninput="setLayerOpacity('drawingCanvas', this.value)">
                        </div>
                        
                        <!-- Layer: Generated Art -->
                        <div class="p-3 border rounded-lg" id="generatedArtLayerControls">
                            <div class="flex justify-between items-center mb-2">
                                <label for="toggleGenerated" class="font-medium text-gray-700">Generated Art</label>
                                <input type="checkbox" id="toggleGenerated" checked onchange="toggleLayer('pixelArtCanvas', this.checked)">
                            </div>
                            <input type="range" min="0" max="100" value="100" class="w-full" oninput="setLayerOpacity('pixelArtCanvas', this.value)">
                        </div>

                        <!-- Layer: Reference Image -->
                        <div class="p-3 border rounded-lg" id="referenceLayerControls">
                            <div class="flex justify-between items-center mb-2">
                                <label for="toggleReference" class="font-medium text-gray-700">Reference Image</label>
                                <input type="checkbox" id="toggleReference" checked onchange="toggleLayer('overlayImage', this.checked)">
                            </div>
                            <input type="range" min="0" max="100" value="100" class="w-full mb-3" oninput="setLayerOpacity('overlayImage', this.value)">
                            
                            <!-- Movement Controls for Reference Image -->
                            <div class="flex justify-between items-center">
                                <span class="text-sm text-gray-500">Move:</span>
                                <div class="flex gap-1">
                                    <button class="control-button w-8 h-8 flex items-center justify-center text-lg" onclick="moveImage(-1, 0)">←</button>
                                    <button class="control-button w-8 h-8 flex items-center justify-center text-lg" onclick="moveImage(0, -1)">↑</button>
                                    <button class="control-button w-8 h-8 flex items-center justify-center text-lg" onclick="moveImage(0, 1)">↓</button>
                                    <button class="control-button w-8 h-8 flex items-center justify-center text-lg" onclick="moveImage(1, 0)">→</button>
                                </div>
                            </div>
                        </div>

                        <!-- Layer: Grid -->
                        <div class="p-3 border rounded-lg">
                            <div class="flex justify-between items-center mb-2">
                                <label for="toggleGrid" class="font-medium text-gray-700">Grid Lines</label>
                                <input type="checkbox" id="toggleGrid" checked onchange="toggleLayer('gridPattern', this.checked)">
                            </div>
                            <input type="range" min="0" max="100" value="100" class="w-full" oninput="setLayerOpacity('gridPattern', this.value)">
                        </div>
                    </div>

                    <!-- Download Button -->
                    <div class="text-center mt-6 pt-4 border-t border-gray-200">
                        <button id="downloadBtn" onclick="downloadPixelArt()" class="w-full p-3 bg-primary text-white font-semibold rounded-lg hover:bg-primary-dark transition shadow-lg">
                            Download Merged Art (PNG)
                        </button>
                    </div>
                </div>
            </div>

            <!-- Grid Display (Right) -->
            <div class="lg:w-2/3 flex flex-col justify-start items-center">
                <div id="gridWrapper" class="layer-container w-full max-w-[800px] rounded-xl overflow-hidden">
                    <!-- Layers will be stacked here in order -->
                    <!-- Layer 1: Reference Image -->
                    <img id="overlayImage" class="canvas-layer" src="https://placehold.co/800x800/e0e0e0/ffffff?text=Start+here" alt="Image Overlay" style="object-fit: cover;">
                    
                    <!-- Layer 2: Generated Pixel Art -->
                    <canvas id="pixelArtCanvas" class="canvas-layer"></canvas>
                    
                    <!-- Layer 3: User Drawing Canvas -->
                    <canvas id="drawingCanvas" class="canvas-layer"></canvas>

                    <!-- Layer 4: Preview Canvas (for shapes) -->
                    <canvas id="previewCanvas" class="canvas-layer" style="pointer-events: none;"></canvas>
                    
                    <!-- Layer 5: Grid Pattern -->
                    <div id="gridPattern" class="canvas-layer"></div>
                    
                </div>

                <!-- Drawing Toolbar -->
                <div id="drawingToolbar" class="w-full max-w-[800px] bg-panel p-3 rounded-xl shadow-lg border border-gray-200 mt-8 flex flex-wrap gap-2 items-center opacity-40 pointer-events-none">
                    
                    <!-- Pencil -->
                    <button id="tool-pencil" class="toolbar-btn active" onclick="setActiveTool('pencil')" title="Pencil (P)">
                        <span class="text-xs font-medium">Pencil</span>
                    </button>
                    
                    <!-- Eraser -->
                    <button id="tool-eraser" class="toolbar-btn" onclick="setActiveTool('eraser')" title="Eraser (E)">
                        <span class="text-xs font-medium">Eraser</span>
                    </button>
                    
                    <!-- Fill Bucket -->
                    <button id="tool-fill" class="toolbar-btn" onclick="setActiveTool('fill')" title="Fill Bucket (F)">
                        <span class="text-xs font-medium">Fill</span>
                    </button>
                    
                    <!-- Eyedropper -->
                    <button id="tool-eyedropper" class="toolbar-btn" onclick="setActiveTool('eyedropper')" title="Eyedropper (I)">
                        <span class="text-xs font-medium">Eyedropper</span>
                    </button>

                    <!-- Line -->
                    <button id="tool-line" class="toolbar-btn" onclick="setActiveTool('line')" title="Line (L)">
                        <span class="text-xs font-medium">Line</span>
                    </button>

                    <!-- Square -->
                    <button id="tool-square" class="toolbar-btn" onclick="setActiveTool('square')" title="Square (S)">
                        <span class="text-xs font-medium">Square</span>
                    </button>

                    <!-- Circle -->
                    <button id="tool-circle" class="toolbar-btn" onclick="setActiveTool('circle')" title="Circle (C)">
                        <span class="text-xs font-medium">Circle</span>
                    </button>

                    <!-- Shape Fill Toggle -->
                    <div id="shapeFillToggleContainer" class="ml-4 flex items-center gap-2" style="display: none;">
                        <input type="checkbox" id="shapeFillToggle" class="w-4 h-4" checked>
                        <label for="shapeFillToggle" class="text-xs font-medium text-gray-700">Fill</label>
                    </div>

                    <!-- Color Picker -->
                    <input type="color" id="colorPicker" value="#000000" class="w-10 h-10 rounded-md border-2 border-gray-300 cursor-pointer ml-auto" oninput="setDrawColor(this.value)">
                </div>

            </div>
        </div>
    </div>

    <!-- NEW: Modal -->
    <div id="modalContainer" class_="" onmousedown="hideModal()">
        <div class="modal-overlay" onmousedown="hideModal()">
            <div class="modal-content" onmousedown="event.stopPropagation();">
                <h3 id="modalTitle" class="text-lg font-bold mb-4">Modal Title</h3>
                <div id="modalContent" class="text-sm mb-6">
                    <p>Modal content goes here.</p>
                </div>
                <div id="modalButtons" class="flex justify-end gap-3">
                    <!-- Buttons are injected here -->
                </div>
            </div>
        </div>
    </div>


    <script>
        // --- Global State ---
        let originalImage = null; // Store the original Image object
        let referenceCanvas = null; // NEW: Hidden canvas for eyedropper sampling
        let imageWidth = 0;
        let imageHeight = 0;
        
        let gridCols = 16;
        let gridRows = 16;
        let pixelationLevel = 1;
        
        let xOffset = 0; // Movement in pixels
        let yOffset = 0; // Movement in pixels
        const MOVE_STEP = 1; // Movement step in pixels

        // Drawing state
        let activeTool = 'pencil'; // 'pencil', 'eraser', 'fill', 'eyedropper', 'line', 'square', 'circle'
        let isDrawing = false;
        let drawColor = '#000000';
        let lastDrawCol = -1;
        let lastDrawRow = -1;
        let brushSize = 1; // NEW: Brush size (1x1, 2x2, etc.)

        // NEW: Shape tool state
        let isShapeTool = false;
        let startDrawCol = 0;
        let startDrawRow = 0;
        let isBlankCanvas = false; // NEW

        // --- DOM Elements ---
        const controlsWrapper = document.getElementById('controlsWrapper');
        const gridWrapper = document.getElementById('gridWrapper');
        const overlayImage = document.getElementById('overlayImage');
        const pixelArtCanvas = document.getElementById('pixelArtCanvas');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const previewCanvas = document.getElementById('previewCanvas'); 
        const gridPattern = document.getElementById('gridPattern');
        const gridSizeLabel = document.getElementById('gridSizeLabel');
        const pixelationValue = document.getElementById('pixelationValue');
        const pixelationSlider = document.getElementById('pixelationSlider'); // NEW
        const drawingToolbar = document.getElementById('drawingToolbar'); 
        const shapeFillToggleContainer = document.getElementById('shapeFillToggleContainer');
        const modalContainer = document.getElementById('modalContainer'); // NEW
        const modalTitle = document.getElementById('modalTitle'); // NEW
        const modalContent = document.getElementById('modalContent'); // NEW
        const modalButtons = document.getElementById('modalButtons'); // NEW
        const generatePixelBtnWrapper = document.getElementById('generatePixelBtnWrapper'); // NEW
        const referenceLayerControls = document.getElementById('referenceLayerControls'); // NEW
        const generatedArtLayerControls = document.getElementById('generatedArtLayerControls'); // NEW
        
        // --- Initialization ---
        
        // NEW: Set initial state
        modalContainer.classList.add('modal-hidden');
        overlayImage.src = 'https://placehold.co/800x800/e0e0e0/ffffff?text=Upload+image+or+Start+Blank';

        function handleImageUpload(event) {
            const file = event.target.files[0];
            const fileNameDisplay = document.getElementById('fileName');

            if (file) {
                fileNameDisplay.textContent = file.name;
                isBlankCanvas = false; // NEW
                pixelationSlider.disabled = false; // NEW
                
                originalImage = new Image();
                originalImage.crossOrigin = "Anonymous";
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    originalImage.src = e.target.result;
                    overlayImage.src = e.target.result; // Set visible reference image
                };
                
                originalImage.onload = () => {
                    // Get native dimensions
                    imageWidth = originalImage.naturalWidth;
                    imageHeight = originalImage.naturalHeight;
                    
                    // Reset sliders and controls
                    document.getElementById('pixelationSlider').value = 1;
                    pixelationLevel = 1;
                    document.getElementById('brushSizeSlider').value = 1; 
                    brushSize = 1;
                    
                    // Setup canvases and grid
                    setupCanvases(imageWidth, imageHeight);
                    updatePixelation(1); // Triggers grid update
                    clearDrawing();
                    
                    // Reset image position
                    xOffset = 0;
                    yOffset = 0;
                    updateImagePosition();

                    // NEW: Show/Enable image-specific controls
                    unlockControls();
                    generatePixelBtnWrapper.style.display = 'block';
                    referenceLayerControls.style.display = 'block';
                    generatedArtLayerControls.style.display = 'block';
                    overlayImage.style.display = 'block';
                };
                
                reader.readAsDataURL(file);
            } else {
                fileNameDisplay.textContent = 'No file selected';
            }
        }

        // NEW: Start with a blank canvas
        function startWithBlankCanvas() {
            const contentHtml = `
                <p class="mb-4 text-gray-600">Choose a size for your pixel art grid.</p>
                <div class="space-y-3">
                    <button class="w-full p-2 border rounded-lg hover:bg-gray-100" onclick="createBlankCanvas(16, 16)">16 x 16</button>
                    <button class="w-full p-2 border rounded-lg hover:bg-gray-100" onclick="createBlankCanvas(32, 32)">32 x 32</button>
                    <button class="w-full p-2 border rounded-lg hover:bg-gray-100" onclick="createBlankCanvas(64, 64)">64 x 64</button>
                    <div class="flex gap-2">
                        <input type="number" id="customWidth" placeholder="Width" class="w-1/2 p-2 border rounded-lg" min="4" max="256" value="32">
                        <input type="number" id="customHeight" placeholder="Height" class="w-1/2 p-2 border rounded-lg" min="4" max="256" value="32">
                    </div>
                </div>`;
            
            const buttons = [
                { text: 'Cancel', class: 'modal-btn-secondary', onclick: hideModal },
                { text: 'Create', class: 'modal-btn-primary', onclick: () => {
                    const w = parseInt(document.getElementById('customWidth').value, 10);
                    const h = parseInt(document.getElementById('customHeight').value, 10);
                    if (w > 0 && h > 0) {
                        createBlankCanvas(w, h);
                    }
                }}
            ];
            
            showModal('New Blank Canvas', contentHtml, buttons);
        }

        // NEW: Helper for blank canvas creation
        function createBlankCanvas(w, h) {
            isBlankCanvas = true; // NEW
            gridCols = w; // NEW: Set grid size directly
            gridRows = h; // NEW: Set grid size directly

            // NEW: Calculate a high-res canvas size
            const baseRes = 800; // Base resolution
            if (w >= h) {
                imageWidth = baseRes;
                imageHeight = Math.round(baseRes * (h / w));
            } else {
                imageHeight = baseRes;
                imageWidth = Math.round(baseRes * (w / h));
            }
            
            originalImage = null; // No reference image
            
            pixelationLevel = 1;
            document.getElementById('pixelationSlider').value = 1;
            pixelationSlider.disabled = true; // NEW: Disable slider
            document.getElementById('brushSizeSlider').value = 1; 
            brushSize = 1;
            
            setupCanvases(imageWidth, imageHeight);
            
            // NEW: Manually update grid labels and pattern
            gridSizeLabel.textContent = `${gridCols}w x ${gridRows}h`;
            pixelationValue.textContent = 1; // Reset this
            updateGridPattern(); // Manually call
            
            clearDrawing();

            // NEW: Hide image-specific controls
            unlockControls();
            generatePixelBtnWrapper.style.display = 'none';
            referenceLayerControls.style.display = 'none';
            generatedArtLayerControls.style.display = 'none';
            overlayImage.style.display = 'none';
            
            hideModal();
        }

        // NEW: Unlock main controls
        function unlockControls() {
            controlsWrapper.classList.remove('opacity-40', 'pointer-events-none');
            drawingToolbar.classList.remove('opacity-40', 'pointer-events-none'); 
        }

        function setupCanvases(w, h) {
            // Set aspect ratio of the container
            gridWrapper.style.aspectRatio = `${w} / ${h}`;
            
            // Set resolution of all canvases
            [pixelArtCanvas, drawingCanvas, previewCanvas].forEach(canvas => { // NEW: Added previewCanvas
                canvas.width = w;
                canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false; // CRITICAL for pixel art
            });
            
            // Create and draw on the hidden reference canvas
            referenceCanvas = document.createElement('canvas');
            referenceCanvas.width = w;
            referenceCanvas.height = h;
            if (originalImage) { // NEW: Only draw if we have an image
                referenceCanvas.getContext('2d').drawImage(originalImage, 0, 0, w, h);
            }
        }
        
        // --- Grid and Pixelation ---

        function updatePixelation(value) {
            if (isBlankCanvas) { // NEW: Don't run this for blank canvas
                pixelationSlider.value = 1;
                return;
            }
            pixelationLevel = parseInt(value, 10);
            pixelationValue.textContent = pixelationLevel;
            
            // Calculate new grid dimensions
            gridCols = Math.round(imageWidth / pixelationLevel);
            gridRows = Math.round(imageHeight / pixelationLevel);
            
            gridSizeLabel.textContent = `${gridCols}w x ${gridRows}h`;
            
            updateGridPattern();
            
            // Clear drawing canvas as the grid has changed
            clearDrawing();
            clearPreview();
        }

        function updateGridPattern() {
            if (gridCols === 0 || gridRows === 0) return;

            // Use percentage for CSS background size
            const bgSizeX = 100 / gridCols;
            const bgSizeY = 100 / gridRows;
            
            gridPattern.style.backgroundSize = `${bgSizeX}% ${bgSizeY}%`;
        }
        
        // --- Image Generation ---
        
        function quantizeColor(r, g, b, bits) {
            if (bits >= 8) return [r, g, b]; // No quantization
            
            const levels = Math.pow(2, bits) - 1;
            const divisor = 255 / levels;
            
            const qr = Math.round( Math.round(r / divisor) * divisor );
            const qg = Math.round( Math.round(g / divisor) * divisor );
            const qb = Math.round( Math.round(b / divisor) * divisor );
            
            return [qr, qg, qb];
        }

        function generatePixelArt() {
            if (!originalImage) return;

            const bitsPerChannel = parseInt(document.getElementById('bitDepthSlider').value, 10);

            // --- Hidden Canvas for Sampling ---
            const hiddenCanvas = document.createElement('canvas');
            hiddenCanvas.width = gridCols;
            hiddenCanvas.height = gridRows;
            const hiddenCtx = hiddenCanvas.getContext('2d');
            hiddenCtx.imageSmoothingEnabled = false;
            
            hiddenCtx.drawImage(originalImage, 0, 0, gridCols, gridRows);
            
            const pixelData = hiddenCtx.getImageData(0, 0, gridCols, gridRows).data;
            
            // --- Draw Blocky Art onto Visible Canvas ---
            const ctx = pixelArtCanvas.getContext('2d');
            ctx.clearRect(0, 0, pixelArtCanvas.width, pixelArtCanvas.height); // Clear previous art
            
            const cellWidth = pixelArtCanvas.width / gridCols;
            const cellHeight = pixelArtCanvas.height / gridRows;

            for (let y = 0; y < gridRows; y++) {
                for (let x = 0; x < gridCols; x++) {
                    const index = (y * gridCols + x) * 4;
                    const r = pixelData[index];
                    const g = pixelData[index + 1];
                    const b = pixelData[index + 2];
                    const a = pixelData[index + 3];

                    if (a > 0) { // Only draw non-transparent pixels
                        const [qr, qg, qb] = quantizeColor(r, g, b, bitsPerChannel);
                        ctx.fillStyle = `rgb(${qr}, ${qg}, ${qb})`;
                        ctx.fillRect(
                            x * cellWidth, 
                            y * cellHeight, 
                            Math.ceil(cellWidth), 
                            Math.ceil(cellHeight)
                        );
                    }
                }
            }
        }

        // --- Layer Controls ---

        function toggleLayer(layerId, isVisible) {
            document.getElementById(layerId).style.display = isVisible ? 'block' : 'none';
        }

        function setLayerOpacity(layerId, value) {
            document.getElementById(layerId).style.opacity = parseFloat(value) / 100;
        }

        function moveImage(dx, dy) {
            xOffset += dx * MOVE_STEP; 
            yOffset += dy * MOVE_STEP; 
            updateImagePosition();
        }

        function updateImagePosition() {
            overlayImage.style.transform = `translate(${xOffset}px, ${yOffset}px)`;
        }

        // --- Drawing Controls ---

        function updateBrushSize(value) {
            brushSize = parseInt(value, 10);
            document.getElementById('brushSizeValue').textContent = `${brushSize}x${brushSize}`;
        }

        function setDrawColor(color) {
            drawColor = color;
            document.getElementById('colorPicker').value = color; // Sync color picker UI
            if (activeTool !== 'pencil' && !isShapeTool) {
                setActiveTool('pencil');
            }
        }
        
        function setActiveTool(tool) {
            activeTool = tool;
            isShapeTool = ['line', 'square', 'circle'].includes(tool);
            
            // Update cursor
            if (tool === 'pencil' || isShapeTool) drawingCanvas.style.cursor = 'crosshair';
            else if (tool === 'eraser') drawingCanvas.style.cursor = 'cell'; 
            else if (tool === 'fill') drawingCanvas.style.cursor = 'copy'; 
            else if (tool === 'eyedropper') drawingCanvas.style.cursor = 'copy';
            
            document.querySelectorAll('.toolbar-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(`tool-${tool}`).classList.add('active');

            shapeFillToggleContainer.style.display = isShapeTool ? 'flex' : 'none';
        }

        // NEW: Confirmation for clearing
        function confirmClearDrawing() {
            const contentHtml = `<p>Are you sure you want to erase your entire drawing?</p>`;
            const buttons = [
                { text: 'Cancel', class: 'modal-btn-secondary', onclick: hideModal },
                { text: 'Yes, Clear', class: 'modal-btn-danger', onclick: () => {
                    clearDrawing();
                    hideModal();
                }}
            ];
            showModal('Clear Drawing', contentHtml, buttons);
        }

        function clearDrawing() {
            const ctx = drawingCanvas.getContext('2d');
            ctx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
        }

        function clearPreview() {
            const ctx = previewCanvas.getContext('2d');
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
        }
        
        // --- Drawing Event Handlers ---
        
        drawingCanvas.addEventListener('mousedown', startDraw);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', endDraw);
        drawingCanvas.addEventListener('mouseleave', endDraw);
        
        // Touch events for mobile
        drawingCanvas.addEventListener('touchstart', startDraw);
        drawingCanvas.addEventListener('touchmove', draw);
        drawingCanvas.addEventListener('touchend', endDraw);

        function getEventCoords(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const event = e.touches ? e.touches[0] : e; // Handle touch or mouse
            
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            
            const x = (event.clientX - rect.left) * scaleX;
            const y = (event.clientY - rect.top) * scaleY;

            const col = Math.floor(x / (drawingCanvas.width / gridCols));
            const row = Math.floor(y / (drawingCanvas.height / gridRows));
            
            return {x, y, col, row};
        }

        function startDraw(e) {
            e.preventDefault();
            const { col, row } = getEventCoords(e);
            
            if (activeTool === 'pencil' || activeTool === 'eraser') {
                isDrawing = true;
                paintBlockAt(col, row); // Paint first block
                lastDrawCol = col;
                lastDrawRow = row;
            } else if (isShapeTool) { // NEW: Shape logic
                isDrawing = true;
                startDrawCol = col;
                startDrawRow = row;
                drawShape(startDrawCol, startDrawRow, col, row); // Draw single point preview
            } else if (activeTool === 'fill') {
                floodFill(e); // Run fill algorithm
            } else if (activeTool === 'eyedropper') {
                pickColor(e); // Run color picker
            }
        }
        
        function draw(e) { // This is mousemove
            if (!isDrawing) return;
            e.preventDefault();
            const { col, row } = getEventCoords(e);

            if (activeTool === 'pencil' || activeTool === 'eraser') {
                if (col !== lastDrawCol || row !== lastDrawRow) {
                    plotLine(lastDrawCol, lastDrawRow, col, row); // Draw line of blocks
                    lastDrawCol = col;
                    lastDrawRow = row;
                }
            } else if (isShapeTool) { // NEW: Shape logic
                clearPreview();
                drawShape(startDrawCol, startDrawRow, col, row); // Draw shape on preview canvas
            }
        }

        function endDraw(e) {
            if (!isDrawing) return;
            e.preventDefault();
            isDrawing = false;
            
            const { col, row } = getEventCoords(e);

            if (isShapeTool) { // NEW: Shape logic
                clearPreview();
                // Stamp final shape onto main drawing canvas
                drawShape(startDrawCol, startDrawRow, col, row, drawingCanvas.getContext('2d'));
            }
            
            lastDrawCol = -1; // Reset last drawn cell
            lastDrawRow = -1;
        }
        
        // --- Brush Drawing Logic ---

        function paintBlockAt(col, row) {
            const ctx = drawingCanvas.getContext('2d');
            const cellWidth = drawingCanvas.width / gridCols;
            const cellHeight = drawingCanvas.height / gridRows;

            const brushOffset = Math.floor((brushSize - 1) / 2);
            const startCol = col - brushOffset;
            const startRow = row - brushOffset;
            const endCol = startCol + brushSize; 
            const endRow = startRow + brushSize;

            ctx.fillStyle = drawColor; // Set style once per block

            for (let r = startRow; r < endRow; r++) {
                for (let c = startCol; c < endCol; c++) {
                    if (c < 0 || c >= gridCols || r < 0 || r >= gridRows) {
                        continue;
                    }
                    
                    const xPos = c * cellWidth;
                    const yPos = r * cellHeight;
                    
                    if (activeTool === 'eraser') {
                        ctx.clearRect(xPos, yPos, Math.ceil(cellWidth), Math.ceil(cellHeight));
                    } else if (activeTool === 'pencil') {
                        ctx.fillRect(xPos, yPos, Math.ceil(cellWidth), Math.ceil(cellHeight));
                    }
                }
            }
        }

        function plotLine(x0, y0, x1, y1) {
            const dx = Math.abs(x1 - x0);
            const dy = -Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx + dy;

            while (true) {
                paintBlockAt(x0, y0);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 >= dy) {
                    err += dy;
                    x0 += sx;
                }
                if (e2 <= dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }

        // --- NEW Shape Drawing Logic ---

        function plotPixel(ctx, x, y, cw, ch) {
            if (x < 0 || x >= gridCols || y < 0 || y >= gridRows) return;
            ctx.fillRect(x * cw, y * ch, Math.ceil(cw), Math.ceil(ch));
        }

        function drawShape(x0, y0, x1, y1, targetCtx = null) {
            const ctx = targetCtx || previewCanvas.getContext('2d');
            const cw = ctx.canvas.width / gridCols;
            const ch = ctx.canvas.height / gridRows;
            const isFilled = document.getElementById('shapeFillToggle').checked;

            ctx.fillStyle = drawColor;
            
            if (activeTool === 'line') {
                plotPixelLine(x0, y0, x1, y1, ctx, cw, ch);
            } else if (activeTool === 'square') {
                plotSquare(x0, y0, x1, y1, ctx, cw, ch, isFilled);
            } else if (activeTool === 'circle') {
                const dx = Math.abs(x1 - x0);
                const dy = Math.abs(y1 - y0);
                const radius = Math.max(dx, dy); // Use Chebyshev distance
                plotCircle(x0, y0, radius, ctx, cw, ch, isFilled);
            }
        }
        
        function plotPixelLine(x0, y0, x1, y1, ctx, cw, ch) {
            const dx = Math.abs(x1 - x0);
            const dy = -Math.abs(y1 - y0);
            const sx = x0 < x1 ? 1 : -1;
            const sy = y0 < y1 ? 1 : -1;
            let err = dx + dy;

            while (true) {
                plotPixel(ctx, x0, y0, cw, ch);
                if (x0 === x1 && y0 === y1) break;
                const e2 = 2 * err;
                if (e2 >= dy) {
                    err += dy;
                    x0 += sx;
                }
                if (e2 <= dx) {
                    err += dx;
                    y0 += sy;
                }
            }
        }
        
        function plotSquare(x0, y0, x1, y1, ctx, cw, ch, filled) {
            const minX = Math.min(x0, x1);
            const maxX = Math.max(x0, x1);
            const minY = Math.min(y0, y1);
            const maxY = Math.max(y0, y1);

            if (filled) {
                for (let y = minY; y <= maxY; y++) {
                    for (let x = minX; x <= maxX; x++) {
                        plotPixel(ctx, x, y, cw, ch);
                    }
                }
            } else {
                plotPixelLine(minX, minY, maxX, minY, ctx, cw, ch); // Top
                plotPixelLine(minX, maxY, maxX, maxY, ctx, cw, ch); // Bottom
                plotPixelLine(minX, minY, minX, maxY, ctx, cw, ch); // Left
                plotPixelLine(maxX, minY, maxX, maxY, ctx, cw, ch); // Right
            }
        }

        // NEW: Replaced circle algorithm
        function plotCircle(xc, yc, r, ctx, cw, ch, filled) {
            let x = 0;
            let y = r;
            let d = 3 - 2 * r;
            
            if (filled) {
                // Use the old filled logic, which draws horizontal lines
                let x_ = r;
                let y_ = 0;
                let err = 0;
                while (x_ >= y_) {
                    plotPixelLine(xc - x_, yc + y_, xc + x_, yc + y_, ctx, cw, ch);
                    plotPixelLine(xc - y_, yc + x_, xc + y_, yc + x_, ctx, cw, ch);
                    plotPixelLine(xc - x_, yc - y_, xc + x_, yc - y_, ctx, cw, ch);
                    plotPixelLine(xc - y_, yc - x_, xc + y_, yc - x_, ctx, cw, ch);
                    y_++;
                    err += 1 + 2*y_;
                    if (2*(err-x_) + 1 > 0) {
                        x_--;
                        err += 1 - 2*x_;
                    }
                }
            } else {
                // New pixel-perfect outline logic (Bresenham/Andres)
                drawCircleOctants(xc, yc, x, y, ctx, cw, ch);
                while (y >= x) {
                    x++;
                    if (d > 0) {
                        y--;
                        d = d + 4 * (x - y) + 10;
                    } else {
                        d = d + 4 * x + 6;
                    }
                    drawCircleOctants(xc, yc, x, y, ctx, cw, ch);
                }
            }
        }

        // NEW: Helper for new circle algorithm
        function drawCircleOctants(xc, yc, x, y, ctx, cw, ch) {
            plotPixel(ctx, xc + x, yc + y, cw, ch);
            plotPixel(ctx, xc - x, yc + y, cw, ch);
            plotPixel(ctx, xc + x, yc - y, cw, ch);
            plotPixel(ctx, xc - x, yc - y, cw, ch);
            plotPixel(ctx, xc + y, yc + x, cw, ch);
            plotPixel(ctx, xc - y, yc + x, cw, ch);
            plotPixel(ctx, xc + y, yc - x, cw, ch);
            plotPixel(ctx, xc - y, yc - x, cw, ch);
        }


        // --- Other Tool Functions ---

        function pickColor(e) {
            const {x, y} = getEventCoords(e); // Note: This is canvas pixels, not grid cells
            let colorData = null;

            // Sample from visible layers, top-down
            if (document.getElementById('toggleDrawing').checked) {
                colorData = drawingCanvas.getContext('2d').getImageData(x, y, 1, 1).data;
            }
            if ((!colorData || colorData[3] === 0) && document.getElementById('toggleGenerated').checked) {
                colorData = pixelArtCanvas.getContext('2d').getImageData(x, y, 1, 1).data;
            }
            // NEW: Check for originalImage before sampling reference
            if ((!colorData || colorData[3] === 0) && document.getElementById('toggleReference').checked && referenceCanvas && originalImage) {
                const refCtx = referenceCanvas.getContext('2d');
                colorData = refCtx.getImageData(x, y, 1, 1).data;
            }

            if (colorData && colorData[3] > 0) { // Found a non-transparent color
                const r = colorData[0];
                const g = colorData[1];
                const b = colorData[2];
                const toHex = c => ('0' + c.toString(16)).slice(-2);
                const hexColor = `#${toHex(r)}${toHex(g)}${toHex(b)}`;
                
                setDrawColor(hexColor);
            }
            
            setActiveTool('pencil');
        }

        function floodFill(e) {
            const { col: startCol, row: startRow } = getEventCoords(e); // Get grid cell
            const ctx = drawingCanvas.getContext('2d');
            
            const cellWidth = drawingCanvas.width / gridCols;
            const cellHeight = drawingCanvas.height / gridRows;

            const sampleX = startCol * cellWidth + cellWidth / 2;
            const sampleY = startRow * cellHeight + cellHeight / 2;
            const startPixel = ctx.getImageData(sampleX, sampleY, 1, 1).data;
            const startColor = `rgb(${startPixel[0]},${startPixel[1]},${startPixel[2]})`;
            const startAlpha = startPixel[3];

            if (drawColor === startColor && startAlpha > 0) return; 
            if (drawColor === startColor && startAlpha === 0 && ctx.fillStyle === startColor) return;

            const queue = [[startCol, startRow]];
            const visited = new Set([`${startCol},${startRow}`]);
            
            const colorsMatch = (p) => {
                if (p[3] !== startAlpha) return false;
                return p[0] === startPixel[0] && p[1] === startPixel[1] && p[2] === startPixel[2];
            };

            while (queue.length > 0) {
                const [col, row] = queue.pop();
                
                ctx.fillStyle = drawColor;
                ctx.fillRect(col * cellWidth, row * cellHeight, Math.ceil(cellWidth), Math.ceil(cellHeight));
                
                const neighbors = [[col + 1, row], [col - 1, row], [col, row + 1], [col, row - 1]];
                
                for (const [nCol, nRow] of neighbors) {
                    const key = `${nCol},${nRow}`;
                    
                    if (nCol < 0 || nCol >= gridCols || nRow < 0 || nRow >= gridRows || visited.has(key)) {
                        continue;
                    }

                    const nX = nCol * cellWidth + cellWidth / 2;
                    const nY = nRow * cellHeight + cellHeight / 2;
                    const neighborPixel = ctx.getImageData(nX, nY, 1, 1).data;
                    
                    if (colorsMatch(neighborPixel)) {
                        visited.add(key);
                        queue.push([nCol, nRow]);
                    }
                }
            }
        }

        // --- Download ---

        function downloadPixelArt() {
            const mergeCanvas = document.createElement('canvas');
            mergeCanvas.width = imageWidth;
            mergeCanvas.height = imageHeight;
            const ctx = mergeCanvas.getContext('2d');
            ctx.imageSmoothingEnabled = false;

            // Draw Generated Art (if visible and exists)
            if (originalImage && document.getElementById('toggleGenerated').checked) {
                ctx.drawImage(pixelArtCanvas, 0, 0);
            }

            // Draw Drawing Layer (if visible)
            if (document.getElementById('toggleDrawing').checked) {
                ctx.drawImage(drawingCanvas, 0, 0);
            }

            // Trigger download
            const dataURL = mergeCanvas.toDataURL('image/png');
            const a = document.createElement('a');
            a.download = `pixel-art-${gridCols}x${gridRows}.png`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // --- NEW: Modal Functions ---
        function showModal(title, contentHtml, buttons = []) {
            modalTitle.textContent = title;
            modalContent.innerHTML = contentHtml;
            
            modalButtons.innerHTML = ''; // Clear old buttons
            buttons.forEach(btn => {
                const buttonEl = document.createElement('button');
                buttonEl.textContent = btn.text;
                buttonEl.className = `modal-btn ${btn.class}`;
                buttonEl.onclick = btn.onclick;
                modalButtons.appendChild(buttonEl);
            });

            modalContainer.classList.remove('modal-hidden');
            modalContainer.classList.add('modal-visible');
        }

        function hideModal() {
            modalContainer.classList.add('modal-hidden');
            modalContainer.classList.remove('modal-visible');
        }

    </script>
</body>
</html>

